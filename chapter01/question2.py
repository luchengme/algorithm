# 前N个自然数的随机序列
# 编写程序，产生前N个自然数的随机序列，如N为5时，{4,3,1,5,2} 和{3,1,4,2,5} 都是正确的，但 {5,4,1,2,1} 就是错误的，因为少了数字3，数字1重复了。
# 至少采用两种算法，分析其时间复杂度
# N取值分别为1千,1万,10万,100万,1000万
# 用表格的形式给出不同N的T和O表达式的值，以及真实运行时间，并画出散点图或折线图

from random import randint
from matplotlib import pyplot as plt
from time import time


# 暴力求解，逐个生成数字
# 如果生成的数字不在里面则填入，否则重新生成
# 只用到了一个数组
def f1(n):
    arr = [0 for _ in range(n)]
    for i in range(n):
        while True:
            temp = randint(1, n)
            if temp not in arr:
                arr[i] = temp
                break
    return arr


# 另外设置一个“标志”数组，用于记录数字是否已存在
def f2(n):
    arr = [0 for _ in range(n)]
    flag = [0 for _ in range(n)]
    for i in range(n):
        temp = randint(1, n)
        while flag[temp - 1] == 1:
            temp = randint(1, n)
        arr[i] = temp
        flag[temp - 1] = 1
    return arr


# 先生成1到n得顺序序列
# 将第i个数字与前面随机一个数字对调
# O(n)
def f3(n):
    arr = [i+1 for i in range(n)]
    for index in range(n):
        temp = randint(0, index)
        arr[index], arr[temp] = arr[temp], arr[index]
    return arr


nums = [i*10000 for i in range(1, 51)]
t1 = []
t2 = []
t3 = []
for n in nums:
    pass
    # temp = time()
    # f1(n)
    # t1.append(time()-temp)

    temp = time()
    f2(n)
    t2.append(time() - temp)
    temp = time()
    f3(n)
    t3.append(time() - temp)

# t2 = [0.17183208465576172, 0.310504674911499, 0.6091933250427246, 0.5936110019683838, 1.0142545700073242, 1.1715872287750244, 1.1433992385864258, 1.6068260669708252, 2.2313218116760254, 1.4813551902770996, 2.2060227394104004, 2.875955820083618, 2.2499184608459473, 2.7969915866851807, 2.997624397277832, 3.7629446983337402, 3.642446756362915, 3.0648138523101807, 3.423339366912842, 3.4562501907348633, 3.924030065536499, 3.6087985038757324, 3.8724594116210938, 3.9753217697143555, 4.687248229980469, 4.801769971847534, 5.224147319793701, 7.153888702392578, 6.109398365020752, 5.306952476501465, 5.933932542800903, 5.775517463684082, 7.108674764633179, 7.181860446929932, 10.402125835418701, 8.438392162322998, 10.257557153701782, 9.496595859527588, 6.784851312637329, 7.302142143249512, 7.09949803352356, 7.430026531219482, 9.038586139678955, 9.35349178314209, 8.638221979141235, 8.497287034988403, 8.808132410049438, 11.933105945587158, 8.233521461486816, 8.148167133331299]
# t3 = [0.0, 0.04687094688415527, 0.03124070167541504, 0.06252121925354004, 0.07807016372680664, 0.09372854232788086, 0.12497663497924805, 0.15620899200439453, 0.15621304512023926, 0.1405951976776123, 0.21869564056396484, 0.21869826316833496, 0.21869683265686035, 0.23435401916503906, 0.2499098777770996, 0.2499399185180664, 0.28118300437927246, 0.31242847442626953, 0.3124234676361084, 0.35929012298583984, 0.3905360698699951, 0.35237860679626465, 0.37491536140441895, 0.4374051094055176, 0.39054203033447266, 0.4530007839202881, 0.4530200958251953, 0.4842567443847656, 0.6248507499694824, 0.6596357822418213, 0.6404819488525391, 0.49228882789611816, 0.5467541217803955, 0.6560909748077393, 0.6458740234375, 0.5724067687988281, 0.6252765655517578, 0.6092240810394287, 0.6404814720153809, 0.6690599918365479, 0.8410863876342773, 0.7029645442962646, 0.6688570976257324, 0.7966859340667725, 0.8124635219573975, 0.7498264312744141, 0.7913131713867188, 0.7766594886779785, 0.7654454708099365, 0.7966794967651367]

fig = plt.figure()
ax = fig.add_axes([0.1, 0.1, 0.8, 0.8])
ax.set_xlabel('nums')
ax.set_ylabel('time')
ax.plot(nums, t2, 'r')
ax.plot(nums, t3, 'b')
ax.legend(labels=('f2', 'f3'), loc=0)
plt.show()
